---
我还是一个新手所以请你一步步来，先实现mvp版本的开发，并且尽可能详细的指导我
---
以下是我的代码，我在做一个日程/时间管理系统，在我的计划中，这个系统应该可以支持两种时间规划：手动输入和自动输入，手动输入可以输入某项任务的起始时间和终止时间，然后记录到数据库中；自动输入点击开始任务就会开始计时，直到用户选择终止任务。不同的任务应该分属于三大类：工作、休闲和睡眠，可以使用可视化的饼图或者柱状图来统计，我已经做了一部分工作如下：
---

根据你的项目现状，建议**第一步先完成计时功能的核心数据库改造**。这是后续所有功能的基础，具体实施步骤如下：

---

### **步骤一：数据库结构升级**
#### 1. 修改`database.py`，新增工作时间记录表
```python
# 修改后的_create_table方法
def _create_table(self):
    # 原有tasks表
    self.conn.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            due_time TEXT)
        """)
    
    # 新增task_sessions表（核心改动）
    self.conn.execute("""
        CREATE TABLE IF NOT EXISTS task_sessions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_id INTEGER NOT NULL,
            start_time TEXT NOT NULL,  # ISO格式时间戳，如'2024-05-23T14:30:00'
            end_time TEXT,
            FOREIGN KEY(task_id) REFERENCES tasks(id))
        """)
    self.conn.commit()
```

#### 2. 添加数据库操作方法
```python
# 在Database类中添加以下方法
def start_timing(self, task_id):
    """开始计时，返回新创建的session_id"""
    cursor = self.conn.execute(
        "INSERT INTO task_sessions (task_id, start_time) VALUES (?, ?) RETURNING id",
        (task_id, datetime.now().isoformat())
    )
    self.conn.commit()
    return cursor.fetchone()[0]

def stop_timing(self, session_id):
    """结束计时"""
    self.conn.execute(
        "UPDATE task_sessions SET end_time=? WHERE id=?",
        (datetime.now().isoformat(), session_id)
    )
    self.conn.commit()
```

---

### **步骤二：界面功能改造**
#### 1. 在任务列表添加操作列
```python
# 修改_build_task_list方法
def _build_task_list(self):
    self.task_list = ttk.Treeview(
        self.list_frame,
        columns=("id", "title", "due_time", "status", "action"),  # 新增两列
        show="headings",
        selectmode="browse"
    )
    
    # 新增列配置
    self.task_list.heading("status", text="计时状态")
    self.task_list.heading("action", text="操作")
    
    # 修改_refresh_task_list方法
    def _refresh_task_list(self):
        # 清空原有数据
        for item in self.task_list.get_children():
            self.task_list.delete(item)
        
        # 查询任务及计时状态（示例SQL）
        cursor = self.db.conn.execute("""
            SELECT t.id, t.title, t.due_time, 
                   (SELECT COUNT(*) FROM task_sessions s 
                    WHERE s.task_id=t.id AND s.end_time IS NULL) AS is_timing
            FROM tasks t
            ORDER BY t.due_time
        """)
        
        for row in cursor:
            task_id, title, due_time, is_timing = row
            status = "进行中" if is_timing else "未开始"
            btn_text = "⏹️ 停止" if is_timing else "▶️ 开始"
            
            # 插入数据行
            item = self.task_list.insert("", "end", values=(task_id, title, due_time, status, btn_text))
            
            # 绑定按钮事件（关键）
            self.task_list.tag_bind(item, "<Button-1>", lambda e, t_id=task_id: self._handle_timing(t_id))
```

#### 2. 实现计时事件处理
```python
# 在App类中添加
def _handle_timing(self, task_id):
    # 获取当前状态
    cursor = self.db.conn.execute(
        "SELECT id FROM task_sessions WHERE task_id=? AND end_time IS NULL",
        (task_id,)
    )
    active_session = cursor.fetchone()
    
    if active_session:  # 存在进行中的计时
        self.db.stop_timing(active_session[0])
    else:  # 新建计时
        self.db.start_timing(task_id)
    
    self._refresh_task_list()  # 刷新界面
```

---

### **步骤三：立即验证**
1. 运行程序测试以下场景：
   - 添加新任务后，点击操作列的"▶️ 开始"按钮
   - 观察数据库`task_sessions`表是否生成记录
   - 再次点击同一任务的"⏹️ 停止"按钮，确认`end_time`被填充

2. 使用DB Browser for SQLite等工具直接查看数据库内容，确认数据符合预期：

   ![task_sessions表示例](https://via.placeholder.com/600x200?text=task_sessions%E8%A1%A8%E7%A4%BA%E4%BE%8B%0Aid|task_id|start_time|end_time%0A1|1|2024-05-23T14:30:00|2024-05-23T15:00:00)

---

### 下一步建议
完成上述基础结构后，你可以：
1. 添加计时可视化显示（当前任务已进行时间）
2. 实现每日/每周的统计图表
3. 增加计时提醒功能

需要任何环节的代码细节或遇到问题，请随时告诉我！建议先集中精力完成这个最小可验证版本（MVP）的计时功能。